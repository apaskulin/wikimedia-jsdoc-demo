<!DOCTYPE html>
<!--[if lte IE 8 ]><html lang="en" class="js-off lte-ie8"><![endif]-->
<!--[if IE 9 ]>    <html lang="en" class="js-off ie9"><![endif]-->
<!--[if (gt IE 9)|!(IE)]><!-->
<html lang="en" class="js-off">
<!--<![endif]-->
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
    <title>Source: mediawiki.editRecovery/edit.js, MediaWiki frontend code, JSDoc</title>
    <script>
document.documentElement.className = document.documentElement.className.replace(/\bjs-off\b/,'js-on'); // no BEM notation thx to IE
    </script>
    <!--[if lt IE 9]>
      <script>window.html5={'shivCSS':false};</script>
      <script src="wmf/js/vendor/ie/html5shiv-3.7.3.min.js"></script>
      <script src="wmf/js/vendor/ie/respond-1.4.2.min.js"></script>
    <![endif]-->
    <link rel="stylesheet" href="styles/jsdoc-wmf-theme.css">
    <script src="scripts/lib/prettify/prettify.js"> </script>
    <script src="scripts/lib/prettify/lang-css.js"> </script>
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link rel="preload" href="wmf/fonts/Charter_regular.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="preload" href="wmf/fonts/Lato_regular.woff2" as="font" type="font/woff2" crossorigin="">
    <script src="scripts/fonts-loader.js" async=""></script>
</head>

<body class="page--home">
	<header id="header" class="header" role="banner">
		<div class="content-box">
			<a href="#content" class="is-aural is-focusable">Jump to content</a>
			<a href="#nav--main" class="is-aural is-focusable">Jump to navigation</a>
			<div class="header__title">
				<span class="site-title"><a href="./"><span class="site-logo"></span>MediaWiki frontend code</a></span>
				<label class="btn--nav-main" for="trigger--nav-main" aria-hidden="true" title="Show main menu">
					<i></i> <span>Menu</span>
				</label>
			</div>
     		<div id="search-container" class="search-container">
  <input type="search" id="lunr-search" class="search-input" role="combobox" aria-autocomplete="list" aria-controls="search-results" aria-expanded="false" aria-activedescendant="selected-search-result" placeholder="Search">
  <ul id="search-results" class="search-results role="listbox"></ul>
</div>
<script src="lunr-data.js"></script>
<script src="scripts/lib/lunr.js"></script>
<script src="scripts/lunrSearch.js"></script>

		</div>
	</header>
	<div class="page">
		<div class="content-box flex-cols">
			<div class="flex-col flex-col--start">
				<input type="checkbox" id="trigger--nav-main" class="trigger--nav-main">
				<nav id="nav--main" class="nav nav--main" role="navigation">
					<ol><li class="nav__item"><a href="index.html">Home</a></li><li class="nav__item"><a href="modules.html">Modules</a><ul class="nav__sub-items"><li class="nav__sub-item"><a href="module-mediawiki.ForeignApi.html">mediawiki.ForeignApi</a></li><li class="nav__sub-item"><a href="module-mediawiki.String.html">mediawiki.String</a></li><li class="nav__sub-item"><a href="module-mediawiki.libs.jpegmeta.html">mediawiki.libs.jpegmeta</a></li><li class="nav__sub-item"><a href="module-mediawiki.libs.pluralruleparser.html">mediawiki.libs.pluralruleparser</a></li><li class="nav__sub-item"><a href="module-mediawiki.notification.convertmessagebox.html">mediawiki.notification.convertmessagebox</a></li><li class="nav__sub-item"><a href="module-mediawiki.page.preview.html">mediawiki.page.preview</a></li><li class="nav__sub-item"><a href="module-mediawiki.page.ready.html">mediawiki.page.ready</a></li><li class="nav__sub-item"><a href="module-mediawiki.page.watch.ajax.html">mediawiki.page.watch.ajax</a></li><li class="nav__sub-item"><a href="module-mediawiki.storage.html">mediawiki.storage</a></li><li class="nav__sub-item"><a href="module-mediawiki.util.html">mediawiki.util</a></li><li class="nav__sub-item"><a href="module-mediawiki.visibleTimeout.html">mediawiki.visibleTimeout</a></li><li class="nav__sub-item"><a href="module-mediawiki.watchstar.widgets.html">mediawiki.watchstar.widgets</a></li><li class="nav__sub-item"><a href="module-moment.html">moment</a></li></ul></li><li class="nav__item"><a href="namespaces.html">Frontend API</a><ul class="nav__sub-items"><li class="nav__sub-item"><a href="Hooks.html">Hooks</a></li><li class="nav__sub-item"><a href="jQueryPlugins.html">jQueryPlugins</a></li><li class="nav__sub-item"><a href="mw.html">mw</a></li><li class="nav__sub-item"><a href="window.html">window</a></li></ul></li><li class="nav__item"><a href="sitemap.html">Sitemap</a></li></ol>
				</nav>
			</div>
			<div class="flex-col flex-col--end">
				<main id="content" class="content" role="main">

    



    
    <section>
        <article>
            <pre class="prettyprint sourcefile linenums"><code>/**
 * In-progress edit recovery for action=edit
 */
'use strict';

const storage = require( './storage.js' );
const LoadNotification = require( './LoadNotification.js' );

const inputFields = {};
const fieldNamePrefix = 'field_';
var originalData = {};
var changeDebounceTimer = null;

// Number of miliseconds to debounce form input.
const debounceTime = 5000;

// This module is loaded for every edit form, but not all should have Edit Recovery functioning.
const isUndo = $( 'input[name="wpUndoAfter"]' ).length > 0;
const isOldRevision = $( 'input[name="oldid"]' ).val() > 0;
const isConflict = mw.config.get( 'wgEditMessage' ) === 'editconflict';
const useEditRecovery = !isUndo &amp;&amp; !isOldRevision &amp;&amp; !isConflict;
if ( useEditRecovery ) {
	mw.hook( 'wikipage.editform' ).add( onLoadHandler );
} else {
	// Always remove the data-saved flag when editing without Edit Recovery.
	// It may have been set by a previous editing session (within 5 minutes) that did use ER.
	mw.storage.session.remove( 'EditRecovery-data-saved' );
}

const windowManager = OO.ui.getWindowManager();
windowManager.addWindows( [ new mw.widgets.AbandonEditDialog() ] );

function onLoadHandler( $editForm ) {
	mw.hook( 'wikipage.editform' ).remove( onLoadHandler );

	// Monitor all text-entry inputs for changes/typing.
	const inputsToMonitorSelector = 'textarea, select, input:not([type="hidden"], [type="submit"])';
	const $inputsToMonitor = $editForm.find( inputsToMonitorSelector );
	$inputsToMonitor.each( function ( _i, field ) {
		if ( field.classList.contains( 'oo-ui-inputWidget-input' ) ) {
			try {
				inputFields[ field.name ] = OO.ui.infuse( field.closest( '.oo-ui-widget' ) );
			} catch ( e ) {
				// Ignore any non-infusable widget because we won't be able to set its value.
			}
		} else {
			inputFields[ field.name ] = field;
		}
	} );
	// Save the contents of all of those, as well as the following hidden inputs.
	const inputsToSaveNames = [ 'wpSection', 'editRevId', 'oldid', 'parentRevId', 'format', 'model', 'mode' ];
	const $inputsToSave = $editForm.find( '[name="' + inputsToSaveNames.join( '"], [name="' ) + '"]' );
	$inputsToSave.each( function ( _i, field ) {
		inputFields[ field.name ] = field;
	} );

	// Store the original data for later comparing to the data-to-save. Use the defaultValue/defaultChecked in order to
	// avoid using any data remembered by the browser. Note that we have to be careful to store with the same types as
	// it will be done later, in order to correctly compare it (e.g. checkboxes as booleans).
	Object.keys( inputFields ).forEach( function ( fieldName ) {
		const field = inputFields[ fieldName ];
		if ( field.nodeName === 'INPUT' || field.nodeName === 'TEXTAREA' ) {
			if ( field.type === 'checkbox' ) {
				// Checkboxes (Minoredit and Watchthis are handled below as they are OOUI widgets).
				originalData[ fieldNamePrefix + fieldName ] = field.defaultChecked;
			} else {
				// Other HTMLInputElements.
				originalData[ fieldNamePrefix + fieldName ] = field.defaultValue;
			}
		} else if ( field.$input !== undefined ) {
			// OOUI widgets, which may not have been infused by this point.
			if ( field.$input[ 0 ].type === 'checkbox' ) {
				// Checkboxes.
				originalData[ fieldNamePrefix + fieldName ] = field.$input[ 0 ].defaultChecked;
			} else {
				// Other OOUI widgets.
				originalData[ fieldNamePrefix + fieldName ] = field.$input[ 0 ].defaultValue;
			}
		}
	} );

	// Open indexedDB database and load any saved data that might be there.
	const pageName = mw.config.get( 'wgPageName' );
	const section = inputFields.wpSection.value || null;
	// Set a short-lived (5m / see postEdit.js) localStorage item to indicate which section is being edited.
	if ( section ) {
		mw.storage.session.set( pageName + '-editRecoverySection', section, 300 );
	}
	storage.openDatabase().then( function () {
		// Check for and delete any expired data for any page, before loading any saved data for the current page.
		storage.deleteExpiredData().then( () => {
			storage.loadData( pageName, section ).then( onLoadData );
		} );
	} );

	// Set up cancel handler to delete data.
	const cancelButton = OO.ui.infuse( $editForm.find( '#mw-editform-cancel' )[ 0 ] );
	cancelButton.on( 'click', function () {
		windowManager.openWindow( 'abandonedit' ).closed.then( function ( data ) {
			if ( data &amp;&amp; data.action === 'discard' ) {
				// Note that originalData is used below in onLoadData() but that's always called before this method.
				// Here we set originalData to null in order to signal to saveFormData() to deleted the stored data.
				originalData = null;
				storage.deleteData( pageName, section ).finally( function () {
					mw.storage.session.remove( pageName + '-editRecoverySection' );
					// Release the beforeunload handler from mediawiki.action.edit.editWarning,
					// per the documentation there
					$( window ).off( 'beforeunload.editwarning' );
					location.href = cancelButton.getHref();
				} );
			}
		} );
	} );
}

function track( metric, value ) {
	const dbName = mw.config.get( 'wgDBname' );
	mw.track( `counter.MediaWiki.edit_recovery.${ metric }.by_wiki.${ dbName }`, value );
}

function onLoadData( pageData ) {
	const wasPosted = mw.config.get( 'wgEditRecoveryWasPosted' );
	if ( wasPosted ) {
		// If this is a POST request, save the current data (e.g. from a preview).
		saveFormData();
	}
	// If there is data stored, load it into the form.
	if ( !wasPosted &amp;&amp; pageData !== undefined &amp;&amp; !isSameAsOriginal( pageData, true ) ) {
		loadData( pageData );
		const loadNotification = new LoadNotification( {
			differentRev: originalData.field_parentRevId !== pageData.field_parentRevId
		} );

		// statsv: Track the number of times the edit recovery notification is shown.
		track( 'show', 1 );

		const notification = loadNotification.getNotification();
		// On 'show changes'.
		loadNotification.getDiffButton().on( 'click', function () {
			$( '#wpDiff' ).trigger( 'click' );
		} );
		// On 'discard changes'.
		loadNotification.getDiscardButton().on( 'click', function () {
			loadData( originalData );
			storage.deleteData( mw.config.get( 'wgPageName' ) ).then( function () {
				notification.close();
			} );
			// statsv: Track the number of times the edit recovery data is discarded.
			track( 'discard', 1 );
		} );
	}

	// Add change handlers.
	Object.keys( inputFields ).forEach( function ( fieldName ) {
		const field = inputFields[ fieldName ];
		if ( field.nodeName !== undefined &amp;&amp; field.nodeName === 'TEXTAREA' ) {
			field.addEventListener( 'input', fieldChangeHandler );
		} else if ( field instanceof OO.ui.Widget ) {
			field.on( 'change', fieldChangeHandler );
		} else {
			field.addEventListener( 'change', fieldChangeHandler );
		}
	} );
	// Also add handlers for when the window is closed or hidden. Saving the data at these points is not guaranteed to
	// work, but it often does and the save operation is atomic so there's no harm in trying.
	window.addEventListener( 'beforeunload', saveFormData );
	window.addEventListener( 'blur', saveFormData );

	/**
	 * Fired after EditRecovery has loaded any recovery data, added event handlers, etc.
	 *
	 * @event ~'editRecovery.loadEnd'
	 * @memberof Hooks
	 * @param {Object} editRecovery
	 * @param {Function} editRecovery.fieldChangeHandler
	 */
	mw.hook( 'editRecovery.loadEnd' ).fire( { fieldChangeHandler: fieldChangeHandler } );
}

function loadData( pageData ) {
	Object.keys( inputFields ).forEach( function ( fieldName ) {
		if ( pageData[ fieldNamePrefix + fieldName ] === undefined ) {
			return;
		}
		const field = inputFields[ fieldName ];
		const $field = $( field );
		// Set the field value depending on what type of field it is.
		if ( field instanceof OO.ui.CheckboxInputWidget ) {
			// OOUI checkbox widgets.
			field.setSelected( pageData[ fieldNamePrefix + fieldName ] );
		} else if ( field instanceof OO.ui.Widget ) {
			// Other OOUI widgets.
			field.setValue( pageData[ fieldNamePrefix + fieldName ], field );
		} else if ( field.nodeName === 'TEXTAREA' ) {
			// Textareas (also reset caret location to top).
			$field.textSelection( 'setContents', pageData[ fieldNamePrefix + fieldName ] );
			$field.textSelection( 'setSelection', { start: 0 } );
		} else {
			// Anything else.
			field.value = pageData[ fieldNamePrefix + fieldName ];
		}
	} );
}

function fieldChangeHandler() {
	clearTimeout( changeDebounceTimer );
	changeDebounceTimer = setTimeout( saveFormData, debounceTime );
}

/**
 * Compare a set of form field values to their original values (as at page load time).
 *
 * @ignore
 * @param {Object} pageData The page data to compare to the original.
 * @param {boolean} ignoreRevIds Do not use parent revision info when determining similarity.
 * @return {boolean}
 */
function isSameAsOriginal( pageData, ignoreRevIds = false ) {
	for ( const fieldName in inputFields ) {
		if ( ignoreRevIds &amp;&amp; ( fieldName === 'editRevId' || fieldName === 'parentRevId' ) ) {
			continue;
		}
		// Trim trailing whitespace from string fields, to approximate what PHP does when saving.
		let currentVal = pageData[ fieldNamePrefix + fieldName ];
		if ( typeof currentVal === 'string' ) {
			currentVal = currentVal.replace( /\s+$/, '' );
		}
		let originalVal = originalData[ fieldNamePrefix + fieldName ];
		if ( typeof originalVal === 'string' ) {
			originalVal = originalVal.replace( /\s+$/, '' );
		}
		if ( currentVal !== originalVal ) {
			return false;
		}
	}
	return true;
}

function saveFormData() {
	const pageName = mw.config.get( 'wgPageName' );
	const section = inputFields.wpSection.value !== undefined ? inputFields.wpSection.value : null;
	const pageData = getFormData();
	storage.saveData( pageName, section, pageData );
	// Flag the data for deletion in the postEdit handler in ./postEdit.js
	mw.storage.session.set( 'EditRecovery-data-saved', true, 300 );
}

/**
 * Get the current form data.
 *
 * @ignore
 * @return {Object}
 */
function getFormData() {
	const formData = {};
	Object.keys( inputFields ).forEach( function ( fieldName ) {
		const field = inputFields[ fieldName ];
		var newValue = null;
		if ( !( field instanceof OO.ui.Widget ) &amp;&amp; field.nodeName !== undefined &amp;&amp; field.nodeName === 'TEXTAREA' ) {
			// Text areas.
			newValue = $( field ).textSelection( 'getContents' );
		} else if ( field instanceof OO.ui.CheckboxInputWidget ) {
			// OOUI checkbox widgets.
			newValue = field.isSelected();
		} else if ( field instanceof OO.ui.Widget ) {
			// Other OOUI widgets.
			newValue = field.getValue();
		} else {
			// Anything else.
			newValue = field.value;
		}
		formData[ fieldNamePrefix + fieldName ] = newValue;
	} );
	return formData;
}
</code></pre>
        </article>
    </section>




				</main>
			</div>
		</div>
	</div>
	<footer id="footer" class="footer">
		<div class="content-box">
			<ul class="footer__list">
				<li><a href="https://gerrit.wikimedia.org/g/mediawiki/core/">Contribute</a></li>
			</ul>
			<p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.2</a> on Mon Mar 25 2024 13:41:33 GMT-0700 (Pacific Daylight Time)</p>
			<p><a href="https://wikimediafoundation.org/" class="lnk--wikimedia-project">A Wikimedia Foundation project</a></p>
		</div>
	</footer>

<script src="scripts/redirect.js"></script>
<script>
var arr = function(aa) { return Array.prototype.slice.call(aa); };
arr(document.querySelectorAll("nav > ol > li a:not([href])")).map(function(el) {
  var li = el;
  while (li && li.tagName !== 'LI') { li = li.parentNode; }
  el.addEventListener('click', function(event) {
    if (li.classList.contains('is-on')) {
      li.classList.remove('is-on');
      return;
    }
    arr(document.querySelectorAll("nav li.nav__item.is-on")).map(function(el2) {
      el2.classList.remove('is-on');
    });
    li.classList.add('is-on');
  });
});
</script>
<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>

<script src="scripts/open-member.js"> </script>
</body>
</html>
